本课程的目的是加深您对CSS的一些最基本概念（级联，特异性和继承）的理解，这些概念控制CSS如何应用于HTML以及如何解决冲突。

与本课程的其他部分相比，本课程的学习似乎没有那么直接的相关性，而且学术性更高，但是对这些内容的理解将为您以后减轻很多痛苦！我们鼓励您仔细阅读本节，并在继续进行之前检查您是否了解这些概念。

| 先决条件： | 基本的计算机知识，已安装的基本软件
| :--------- | ------------------------------------------------------------ |
| 目的：     | 了解级联和特定性，以及CSS如何继承。                          |

## 规则冲突

CSS代表**Cascading Style Sheets**（**层叠样式表）**，而第一个单词的*层叠*对于理解它非常重要-级联的行为方式是理解CSS的关键。

有时，您将在一个项目上工作，并且发现您认为应该应用于元素的CSS无法正常工作。通常问题是您创建了两个规则，它们可能适用于同一元素。该**级联**和的密切相关的概念**的特异性**，是机制，控制，当有这样的冲突规则适用。哪个元素在样式上可能不是您所期望的，因此您需要了解这些机制的工作方式。

**继承**的概念在这里也很重要，这意味着默认情况下，某些CSS属性会继承在当前元素的父元素上设置的值，而有些则不会。这也可能导致某些您可能无法预期的行为。

让我们开始快速浏览一下我们正在处理的关键事物，然后我们依次研究它们，看看它们如何相互影响以及与CSS的相互作用。这似乎是一组难以理解的棘手概念。但是，随着您越来越多地编写CSS练习，它的工作方式将对您变得更加明显。

### 级联



样式表**级联** -在非常简单的级别上，这意味着CSS规则的顺序很重要；当应用两个具有相同特异性的规则时，将在CSS中排在最后的那个将被使用。

在以下示例中，我们有两个适用于的规则`h1`。所述`h1`向上的端部被着色为蓝色-这些规则具有相同的选择器，并且因此携带相同的特异性，所以最后一个在源顺序获胜。

```html
h1 { 
    color: red; 
}
h1 { 
    color: blue; 
}
```



<h1>This is my heading.</h1> 
### 特异性



如果多个规则具有不同的选择器，但浏览器如何决定哪个规则适用，但是仍然可以应用于同一元素，则是特殊性。基本上，这是对选择器选择的具体程度的一种度量：

- 元素选择器不太具体-它会选择页面上显示的该类型的所有元素-因此得分会降低。
- 类选择器更为具体-它只会选择页面上具有特定`class`属性值的元素-因此得分会更高。

时间示例！下面我们再次有两个适用于的规则`h1`。下面的内容`h1`最终变为红色-类选择器为其规则赋予了更高的特异性，因此即使带有元素选择器的规则在源顺序中排在更下方，该规则也将被应用。

```html
.main-heading { 
    color: red; 
}
        
h1 { 
    color: blue; 
}
```



 <h1 class="main-heading">This is my heading.</h1>
我们将在以后解释特异性评分和其他类似的事情。

### 遗产



在这种情况下，也需要了解继承-在父元素上设置的某些CSS属性值是由其子元素继承的，而有些则不是。

例如，如果在元素上设置`color`和`font-family`，除非它直接应用了不同的颜色和字体值，否则每个元素内的元素也将使用该颜色和字体设置样式。

```html
body {
    color: blue;
}

span {
    color: black;
}
    
```



<p>As the body has been set to have a color of blue this is inherited through the descendants.</p>
<p>We can change the color by targetting the element with a selector, such as this <span>span</span>.</p>
某些属性不会继承-例如，如果您`width`在元素上设置50％的值，则其所有后代的宽度都不会达到其父级宽度的50％。如果真是这样，CSS将会非常令人沮丧！



## 了解概念如何协同工作

这三个概念共同控制哪个CSS适用于哪个元素；在以下各节中，我们将看到它们如何协同工作。有时似乎有些复杂，但是随着您对CSS的使用越来越多，您将开始记住它们，如果忘记了，您总是可以查找细节！即使是经验丰富的开发人员也不会记住所有细节。

## 了解继承

我们将从继承开始。在下面的示例中，我们有一个`<ul>`，其中嵌套了两层无序列表。我们给了外部`<ul>`边框，填充和字体颜色。

颜色适用于直接子代，也适用于间接子代-直接子代`<li>`和第一个嵌套列表内的子代。然后，`special`我们在第二个嵌套列表中添加的类，并为其应用了不同的颜色。然后，通过其子项继承下来。

 

宽度（如上所述），边距，填充和边框等内容不会继承。如果要由我们列表的子代继承边框，则每个列表和列表项都将具有边框-可能不是我们想要的效果！

```
.main {
    color: rebeccapurple;
    border: 2px solid #ccc;
    padding: 1em;
}

.special {
    color: black;
    font-weight: bold;
}
```

```
<ul class="main">
    <li>Item One</li>
    <li>Item Two
        <ul>
            <li>2.1</li>
            <li>2.2</li>
        </ul>
    </li>
    <li>Item Three
        <ul class="special">
            <li>3.1
                <ul>
                    <li>3.1.1</li>
                    <li>3.1.2</li>
                </ul>
            </li>
            <li>3.2</li>
        </ul>
    </li>
</ul>
    
```



哪些属性默认情况下是继承的，哪些不是默认情况下的继承。



### 控制继承



CSS提供了四个特殊的通用属性值来控制继承。每个CSS属性都接受这些值。

- `inherit`

  将应用于选定元素的属性值设置为其父元素的属性值。实际上，这是“继承”。

- `initial`

  将应用于所选元素的属性值设置为与浏览器默认样式表中对该元素上的该属性设置的值相同。如果浏览器的默认样式表未设置任何值，并且自然继承了该属性，则将属性值设置为`inherit`。

- `unset`

  将属性重置为其自然值，这意味着，如果该属性是自然继承的，则其行为类似于`inherit`，否则，其行为类似于`initial`。

**注意**：还有一个新值 `revert`，它对浏览器的支持有限。


我们可以查看链接列表，并探讨通用值的工作方式。下面的实时示例使您可以使用CSS并查看进行更改后会发生什么。玩代码确实是掌握HTML和CSS的最佳方法。

例如：

1. 第二个列表项已`my-class-1`应用该类。这将设置`<li>`嵌套在内部的元素的颜色以进行继承。如果删除规则，它将如何更改链接的颜色？
2. 您了解第三和第四链接为什么是它们的颜色吗？如果没有，请检查以上值的描述。
3. 如果您为`<a>`元素定义新颜色，那么哪个链接会更改颜色`a { color: red; }`？例如？

 

```
body {
    color: green;
}
          
.my-class-1 a {
    color: inherit;
}
          
.my-class-2 a {
    color: initial;
}
          
.my-class-3 a {
    color: unset;
}
    
```

```
<ul>
    <li>Default <a href="#">link</a> color</li>
    <li class="my-class-1">Inherit the <a href="#">link</a> color</li>
    <li class="my-class-2">Reset the <a href="#">link</a> color</li>
    <li class="my-class-3">Unset the <a href="#">link</a> color</li>
</ul>
```





### 重置所有属性值



CSS速记属性`all`可用于一次将这些继承值之一应用于（几乎）所有属性。其值可以是继承值中的任何一个（`inherit`，`initial`，`unset`，或`revert`）。这是撤消对样式所做的更改的便捷方法，以便您可以在开始新更改之前回到已知的起点。

在下面的示例中，我们有两个块引用。第一个样式应用于blockquote元素本身，第二个样式应用于classquote，将class的值设置`all`为`unset`。

 ```
blockquote {
    background-color: red;
    border: 2px solid green;
}
        
.fix-this {
    all: unset;
}
   
 ```

```
        <blockquote>
            <p>This blockquote is styled</p>
        </blockquote>

        <blockquote class="fix-this">
            <p>This blockquote is not styled</p>
        </blockquote>
    
```



尝试将的值设置为`all`其他一些可用值，然后观察一下两者之间的区别。

## 了解级联

现在，我们了解了为什么嵌套在HTML结构深处的段落与应用于正文的CSS具有相同的颜色，并且通过入门课程，我们了解了如何在文档的任何位置更改应用于某些内容的CSS —通过将CSS分配给元素或创建类。现在，我们将正确看一看当多个元素可以样式化元素时，级联如何定义应用哪些CSS规则。

需要考虑三个因素，这里按重要性从高到低的顺序列出。较早的优先于较晚的：

1. **重要性**
2. **特异性**
3. **源顺序**

我们将自下而上查看这些内容，以了解浏览器如何准确地确定应使用哪种CSS。

### 源顺序



我们已经了解了源顺序对级联的重要性。如果您拥有多个权重完全相同的规则，那么CSS中倒数第二个规则将获胜。您可以将其视为规则，该规则更接近元素本身，覆盖早期的规则，直到最后一个规则获胜并开始为元素设置样式。

### 特异性



一旦了解了源顺序很重要的事实，您就会在某种程度上遇到一种情况，即您知道规则在样式表中稍后出现，但是会应用较早的，冲突的规则。这是因为较早的规则具有**更高的特异性** -它具有更高的特异性，因此被浏览器选择为应为元素设置样式的规则。

正如我们在本课程前面所看到的，类选择器比元素选择器具有更大的权重，因此在类上定义的属性将覆盖直接应用于元素的那些属性。

这里要注意的一点是，尽管我们正在考虑选择器以及应用于选择器的规则，但并不是整个规则都被覆盖，而是相同的属性。

此行为有助于避免CSS中的重复。一种常见的做法是为基本元素定义通用样式，然后为不同的元素创建类。例如，在下面的样式表中，我们为2级标题定义了通用样式，然后创建了一些仅更改某些属性和值的类。最初定义的值将应用于所有标题，然后将更具体的值应用于具有类的标题。

 ```
h2 {
    font-size: 2em;
    color: #000;
    font-family: Georgia, 'Times New Roman', Times, serif;
}
        
.small {
    font-size: 1em;
}
        
.bright {
    color: rebeccapurple;
}         
 
 ```

```
<h2>Heading with no class</h2>
<h2 class="small">Heading with class of small</h2>
<h2 class="bright">Heading with class of bright</h2>
    
```



现在让我们看一下浏览器如何计算特异性。我们已经知道元素选择器的特异性很低，可以被类覆盖。从本质上讲，分类型的选择器将获得一个点值，将这些值相加即可得出该特定选择器的权重，然后可以根据其他潜在匹配项对该权重进行评估。

选择器具有的特异性程度是使用四个不同的值（或分量）来衡量的，可以将其视为成千上万，数百个，十个和一个-四列中的四个个位数：

1. **千**：如果声明位于`style`属性（也称为内联样式）内，则在此列中得分一。这样的声明没有选择器，因此它们的特异性始终只是1000。
2. **数百**：在此列中为整体选择器中包含的每个ID选择器打一分。
3. **十分**：在此列中为整体选择器中包含的每个类选择器，属性选择器或伪类得分。
4. **一个**：在此列中为整体选择器中包含的每个元素选择器或伪元素打分。

**注**：通用选择（`*`），组合子（`+`，`>`，`~`，'“），以及否定伪类（`:not`）对特异性没有影响。


| 选择器                                    | 千   | 几百个 | 十   | 那些 | 总特异性 |
| :---------------------------------------- | :--- | :----- | :--- | :--- | :------- |
| `h1`                                      | 0    | 0      | 0    | 1个  | 0001     |
| `h1 + p::first-letter`                    | 0    | 0      | 0    | 3    | 0003     |
| `li > a[href*="en-US"] > .inline-warning` | 0    | 0      | 2    | 2    | 0022     |
| `#identifier`                             | 0    | 1个    | 0    | 0    | 0100     |
| 没有选择器，在元素`style`属性内有规则     | 1个  | 0      | 0    | 0    | 1000     |

在继续之前，让我们看一个实际的例子。

 ```

/* specificity: 0101 */
#outer a {
    background-color: red;
}
        
/* specificity: 0201 */
#outer #inner a {
    background-color: blue;
}

/* specificity: 0104 */
#outer div ul li a {
    color: yellow;
}

/* specificity: 0113 */
#outer div ul .nav a {
    color: white;
}

/* specificity: 0024 */
div div li:nth-child(2) a:hover {
    border: 10px solid black;
}

/* specificity: 0023 */
div li:nth-child(2) a:hover {
    border: 10px dashed black;
}

/* specificity: 0033 */
div div .nav:nth-child(2) a:hover {
    border: 10px double black;
}

a {
    display: inline-block;
    line-height: 40px;
    font-size: 20px;
    text-decoration: none;
    text-align: center;
    width: 200px;
    margin-bottom: 10px;
}

ul {
    padding: 0;
}

li {
    list-style-type: none;
}            
    
 ```

```
<div id="outer" class="container">
    <div id="inner" class="container">
        <ul>
            <li class="nav"><a href="#">One</a></li>
            <li class="nav"><a href="#">Two</a></li>
        </ul>
    </div>
</div>
    
```



那么这是怎么回事？首先，我们只对本示例的前七个规则感兴趣，并且您会注意到，我们在每个注释之前的注释中都包含了它们的特异性值。

- 前两个选择器在争夺链接背景颜色的样式上竞争-第二个选择器获胜并使背景颜色变成蓝色，因为它在链中有一个额外的ID选择器：其特异性是201对101。
- 第三和第四个选择器正在争夺链接文本颜色的样式-第二个选择器获胜并使文本变白，因为尽管元素选择器少了一个，但缺少的选择器却换成了一个类选择器，它值得十个比一个。因此获胜的特异性是113比104。
- 选择器5–7悬停在链接边界的样式上竞争。选择器6显然输给了五个，特异性为23 vs. 24-链中少了一个元素选择器。然而，选择器7击败了五个和六个，它在子链中具有与五个相同的子选择器数量，但是一个元素已换成类选择器。因此获胜的特异性是33 vs 23和24。



**注意**：仅为了便于理解，这仅是一个近似示例。实际上，每种选择器类型都有其自己的特定性，不能被较低特定性级别的选择器覆盖。例如，组合在一起的一*百万个* **类**选择器将无法覆盖*一个* **id**选择器的规则。

评估特异性的更准确方法是对特异性水平分别评分，从最高开始，必要时降至最低。只有在特定性水平内的选择器得分之间存在平局时，才需要评估下一个水平。否则，您可以忽略较低特异性级别的选择器，因为它们永远不会覆盖较高特异性级别的选择器。

### ！重要



您可以使用一个特殊的CSS来推翻所有上述计算，但是使用它时应格外小心`!important`。这用于使特定属性和值成为最特定的事物，从而超越了级联的常规规则。

看一下这个示例，其中有两个段落，其中一个具有ID。

```
#winning {
    background-color: red;
    border: 1px solid black;
}
    
.better {
    background-color: gray;
    border: none !important;
}
    
p {
    background-color: blue;
    color: white;
    padding: 5px;
}           
```



<p class="better">This is a paragraph.</p>
<p class="better" id="winning">One selector to rule them all!</p>
让我们逐步了解一下发生了什么—尝试删除一些属性，以查看如果发现难以理解将发生什么：

1. 您会看到已经应用了第三条规则`color`和`padding`值，但尚未应用`background-color`。为什么？确实，这三个都应该确实适用，因为源顺序中的较后规则通常会覆盖较早的规则。
2. 但是，上面的规则会获胜，因为类选择器比元素选择器具有更高的特异性。
3. 这两种元素都有`class`的`better`，但第二个一个有一个`id`的`winning`了。由于ID 比类具有*更高的*特异性（页面上每个ID只能具有一个元素，但是具有相同类的许多元素-ID选择器*针对的*对象*非常具体*），红色背景色和1像素黑色边框应同时应用于第二个元素，第一个元素将获得灰色背景色，并且没有边框（如该类所指定）。
4. 第二个元素*的确*获得红色背景色，但没有边框。为什么？由于`!important`第二条规则中的声明-后面加上该字符串`border: none`意味着即使ID具有更高的特异性，此声明也将胜过上一条规则中的边界值。

**注意**：覆盖此`!important`声明的唯一方法是在源顺序中稍后在*同一*`!important`声明中包含另一个声明，或者在声明中具有更高的特异性。

知道`!important`存在是很有用的，这样当您在其他人的代码中遇到它时，便知道它是什么。**但是，强烈建议您除非绝对必要，否则不要使用它。** `!important`更改了级联的正常工作方式，因此它会使调试CSS问题变得非常困难，尤其是在大型样式表中。

您可能需要使用它的一种情况是，在CMS上工作时，您无法编辑核心CSS模块，而您确实想覆盖无法以其他任何方式覆盖的样式。但实际上，如果可以避免，请勿使用它。

## CSS位置的影响

最后，注意到CSS声明的重要性取决于在其中指定的样式表，这很有用-用户可以设置自定义样式表来覆盖开发人员的样式，例如，用户可能在视觉上有缺陷，并且想要将其访问的所有网页上的字体大小设置为正常大小的两倍，以便于阅读。

## 总结一下

冲突的声明将按以下顺序应用，后面的声明将覆盖前面的声明：

1. 用户代理样式表中的声明（例如，浏览器的默认样式，未设置其他样式时使用）。
2. 用户样式表中的常规声明（用户设置的自定义样式）。
3. 作者样式表中的常规声明（这些是我们，Web开发人员设置的样式）。
4. 作者样式表中的重要声明
5. 用户样式表中的重要声明

Web开发人员的样式表覆盖用户样式表是有意义的，因此可以按预期进行设计，但是如上所述，有时用户有充分的理由覆盖Web开发人员样式-这可以通过`!important`在其规则中使用来实现。