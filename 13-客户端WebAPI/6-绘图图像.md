该浏览器包含一些非常强大的图形编程工具，从可伸缩矢量图形（[SVG](1/en-US/docs/Web/SVG)）语言到用于在HTML `<canvas>`元素上绘图的API （请参阅[Canvas API](1/en-US/docs/Web/API/Canvas_API)和[WebGL](1/en-US/docs/Web/API/WebGL_API)）。本文提供了canvas的介绍，并提供了更多资源来使您了解更多。

| 先决条件： | JavaScript基础知识（请参阅[第一步](1/en-US/docs/Learn/JavaScript/First_steps)，[构建基块](1/en-US/docs/Learn/JavaScript/Building_blocks)，[JavaScript对象](1/en-US/docs/Learn/JavaScript/Objects)），[客户端API](1/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction)的[基础知识](1/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction) |
| :--------- | ------------------------------------------------------------ |
| 目的：     | 了解`<canvas>`使用JavaScript 绘制元素的基础知识。            |

## 网络上的图形

正如我们在HTML [多媒体和嵌入](1/en-US/docs/Learn/HTML/Multimedia_and_embedding)模块中所讨论的那样，Web最初只是文本，非常无聊，因此引入了图像-首先通过`<img>`元素，然后通过CSS属性（例如[`background-image`]( /background-image)和[SVG）](1/en-US/docs/Web/SVG)引入了图像。

但是，这还不够。尽管可以使用[CSS](1/en-US/docs/Learn/CSS)和[JavaScript](1/en-US/docs/Learn/JavaScript)来动画化（或操纵）SVG矢量图像（以标记表示），但仍然无法对位图图像执行相同的操作，并且可用的工具相当有限。Web仍然没有办法有效地创建动画，游戏，3D场景以及通常由较低级别的语言（例如C ++或Java）处理的其他要求。

当浏览器开始支持该`<canvas>`元素和相关的[Canvas API](1/en-US/docs/Web/API/Canvas_API)时，情况开始改善。Apple于2004年左右发明了该元素，随后的几年中，其他浏览器又实现了它。正如您将在下面看到的那样，canvas提供了许多有用的工具来创建2D动画，游戏，数据可视化以及其他类型的应用程序，尤其是与Web平台提供的其他一些API结合使用时。



在2006–2007年左右，Mozilla开始进行实验性3D画布实现的工作。这就是[WebGL](1/en-US/docs/Web/API/WebGL_API)，在浏览器供应商中吸引了人们的注意，并于2009-2010年左右标准化。WebGL允许您在Web浏览器中创建真实的3D图形。

由于原始的WebGL代码非常复杂，因此本文将主要关注2D canvas。但是，我们将展示如何使用WebGL库更轻松地创建3D场景，并且您可以在其他地方找到涵盖原始WebGL的教程-请参阅[WebGL入门](1/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL)。

**注意**：基本的画布功能在所有浏览器中均受良好支持，但2D画布的IE 8及以下版本以及WebGL的IE 11及以下版本除外。

## 主动学习：`<canvas>`入门

如果要在网页上创建2D *或* 3D场景，则需要从HTML `<canvas>`元素开始。此元素用于定义页面上要在其中绘制图像的区域。这就像在页面上包含元素一样简单：

```html
<canvas width="320" height="240"></canvas>
```

这将在页面上创建一个尺寸为320 x 240像素的画布。

在canvas标记内，您可以放置一些后备内容，如果用户的浏览器不支持画布，则会显示这些内容。

```html
<canvas width="320" height="240">
  <p>Your browser doesn't support canvas. Boo hoo!</p>
</canvas>
```

当然，以上消息确实没有帮助！在一个真实的示例中，您希望将后备内容与画布内容相关联。例如，如果您要绘制一个不断更新的股价图，则后备内容可能是最新股价图的静态图像，其中的替代文字说明了价格在文字中的含义。

### 创建画布并调整其大小



让我们从创建自己的画布开始，然后将其用于将来的实验。

1. 首先，对我们的[0_canvas_start.html](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/0_canvas_start.html)文件进行本地复制，然后在文本编辑器[中将](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/0_canvas_start.html)其打开。

2. 在开始`<body>`标记的正下方添加以下代码：

   ```html
   <canvas class="myCanvas">
     <p>Add suitable fallback here.</p>
   </canvas>
   ```

   我们`class`在`<canvas>`元素中添加了一个，因此如果页面上有多个画布，则选择起来会更容易，但是我们现在已经删除了`width`和`height`属性（可以根据需要添加它们，但是我们将使用JavaScript进行设置）在下面的部分中）。没有明确的宽度和高度的画布默认为300像素宽x 150像素高。

3. 现在，在`<script>`元素内添加以下JavaScript行：

   ```js
   const canvas = document.querySelector('.myCanvas');
   const width = canvas.width = window.innerWidth;
   const height = canvas.height = window.innerHeight;
   ```

   在这里，我们在`canvas`常量中存储了对canvas的引用。在第二行中，我们既设置了新的常量`width`，又将canvas的`width`属性设置为等于[`Window.innerWidth`](1/en-US/docs/Web/API/Window/innerWidth)（这为我们提供了视口宽度）。在第三行中，我们既设置了新的常量`height`，又将canvas的`height`属性设置为等于[`Window.innerHeight`](1/en-US/docs/Web/API/Window/innerHeight)（这为我们提供了视口高度）。现在，我们有了一个画布，它可以填充浏览器窗口的整个宽度和高度！

   您还将看到我们将赋值与多个等号链接在一起-JavaScript允许这样做，并且如果要使多个变量都等于相同的值，这是一种很好的技术。我们希望在width / height变量中易于访问画布的宽度和高度，因为它们是有用的值，可在以后使用（例如，如果要在画布的宽度上绘制一半的东西）。

4. 如果您现在将示例保存并加载到浏览器中，您将看不到任何内容，这很好，但是您还将看到滚动条，这对我们来说是个问题，因为`<body>`元素中包含[`margin`]( /margin)那个，所以添加到了-window-size画布，生成的文档比窗口宽。要摆脱滚动条，我们需要删除，[`margin`]( /margin)并将其设置[`overflow`]( /overflow)为`hidden`。将以下内容添加到`<head>`文档的中：

   ```html
   <style>
     body {
       margin: 0;
       overflow: hidden;
     }
   </style>
   ```

   滚动条现在应该消失了。

**注意**：如上所述，通常应该使用HTML属性或DOM属性设置图像的大小。您可以使用CSS，但麻烦的是在画布渲染后完成大小调整，就像其他任何图像（渲染的画布只是图像）一样，该图像可能会像素化/扭曲。

### 获取画布上下文和最终设置



在考虑画布模板完成之前，我们需要做最后一件事。要在画布上绘制，我们需要获得对绘制区域的特殊引用，称为上下文。这是使用[`HTMLCanvasElement.getContext()`](1/en-US/docs/Web/API/HTMLCanvasElement/getContext)方法完成的，对于基本用法，该方法将单个字符串作为代表您要检索的上下文类型的参数。

在这种情况下，我们需要一个2d画布，因此在`<script>`元素内的其他行下方添加以下JavaScript行：

```js
const ctx = canvas.getContext('2d');
```

**注意**：您可以选择的其他上下文值包括`webgl`WebGL，`webgl2`WebGL 2等，但是本文中不需要这些值。

就是这样-我们的画布现在已经上底漆并准备好进行绘图了！该`ctx`变量现在包含一个[`CanvasRenderingContext2D`](1/en-US/docs/Web/API/CanvasRenderingContext2D)对象，并在画布上绘制的所有操作都将涉及操纵这个对象。

在继续之前，让我们做最后一件事。我们将画布背景涂成黑色，以使您对画布API有所了解。在JavaScript底部添加以下行：

```js
ctx.fillStyle = 'rgb(0, 0, 0)';
ctx.fillRect(0, 0, width, height);
```

在这里，我们使用canvas的[`fillStyle`](1/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle)属性设置填充颜色（就像CSS属性一样使用[颜色值](1/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units#Colors)），然后使用方法绘制一个覆盖画布整个区域的矩形[`fillRect`](1/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect)（前两个参数是矩形的坐标）左上角；最后两个是您要在其上绘制矩形的宽度和高度-我们告诉您这些`width`和`height`变量将很有用）！

好的，我们的模板已经制作好了，该继续了。

## 2D画布基础知识

如上所述，所有绘制操作都是通过操纵一个[`CanvasRenderingContext2D`](1/en-US/docs/Web/API/CanvasRenderingContext2D)对象（在我们的示例中为`ctx`）来完成的。需要为许多操作提供坐标以精确指出要在哪里绘制东西–画布的左上方是点（0，0），水平（x）轴从左到右，垂直（y）轴从从上到下。

![img](https://mdn.mozillademos.org/files/224/Canvas_default_grid.png)

绘制形状倾向于使用矩形形状图元完成，或者通过沿特定路径描画一条线然后填充该形状来完成。下面我们将展示如何做到这两种。

### 简单矩形



让我们从一些简单的矩形开始。

1. 首先，获取新编码的画布模板的副本（如果不执行上述步骤，请复制[1_canvas_template.html](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/1_canvas_template.html)的本地副本）。

2. 接下来，将以下行添加到JavaScript的底部：

   ```js
   ctx.fillStyle = 'rgb(255, 0, 0)';
   ctx.fillRect(50, 50, 100, 150);
   ```

   如果保存并刷新，您应该看到画布上出现了一个红色矩形。它的左上角距离画布边缘的顶部和左侧50像素（由前两个参数定义），并且它的宽度为100像素，高度为150像素（由第三和第四参数定义）。

3. 让我们在混合中添加另一个矩形-这次是绿色。在JavaScript的底部添加以下内容：

   ```js
   ctx.fillStyle = 'rgb(0, 255, 0)';
   ctx.fillRect(75, 75, 100, 100);
   ```

   保存并刷新，您将看到新的矩形。这就提出了一个重要的观点：图形操作（如绘制矩形，线条等）以它们发生的顺序执行。可以把它想象成是一堵墙，每层油漆都重叠在一起，甚至可能隐藏下面的东西。您无法采取任何措施来更改此设置，因此您必须仔细考虑绘制图形的顺序。

4. 请注意，您可以通过指定半透明颜色来绘制半透明图形，例如使用`rgba()`。该`a`值定义所谓的“ alpha通道”或颜色具有的透明度。它的价值越高，其背后的内容就会越模糊。将以下内容添加到您的代码中：

   ```js
   ctx.fillStyle = 'rgba(255, 0, 255, 0.75)';
   ctx.fillRect(25, 100, 175, 50);
   ```

5. 现在尝试绘制更多自己的矩形。玩得开心！

### 描边和线宽



到目前为止，我们已经研究了绘制填充的矩形，但是您也可以绘制只是轮廓的矩形（在图形设计中称为**笔触**）。要设置您想要的笔触颜色，请使用[`strokeStyle`](1/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle)属性。使用绘制笔触矩形[`strokeRect`](1/en-US/docs/Web/API/CanvasRenderingContext2D/strokeRect)。

1. 将以下内容添加到前面的示例中，再次在前面的JavaScript行下面：

   ```js
   ctx.strokeStyle = 'rgb(255, 255, 255)';
   ctx.strokeRect(25, 25, 175, 200);
   ```

2. 笔划的默认宽度为1像素；您可以调整[`lineWidth`](1/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth)属性值以更改此值（它需要一个数字来表示笔划的像素宽）。在前两行之间添加以下行：

   ```js
   ctx.lineWidth = 5;
   ```

### 绘制路径



如果要绘制比矩形更复杂的内容，则需要绘制路径。基本上，这涉及编写代码以确切指定笔应在画布上沿着什么路径移动以追踪要绘制的形状。画布包括用于绘制直线，圆，贝塞尔曲线等的功能。

让我们从制作画布模板的新副本（[1_canvas_template.html](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/1_canvas_template.html)）开始，开始绘制新示例。

我们将在以下所有部分中使用一些通用的方法和属性：

- [`beginPath()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath)—在笔当前在画布上的位置开始绘制路径。在新的画布上，笔从（0，0）开始。
- [`moveTo()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/moveTo)—将笔移动到画布上的其他点，而无需记录或跟踪线条；笔只是“跳”到新位置。
- [`fill()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/fill) -通过填写到目前为止已跟踪的路径来绘制填充形状。
- [`stroke()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/stroke) -通过沿到目前为止绘制的路径绘制笔划来绘制轮廓形状。
- 您还可以将诸如/ `lineWidth`和`fillStyle`/之类的功能`strokeStyle`与路径以及矩形一起使用。

一个典型的简单路径绘制操作如下所示：

```js
ctx.fillStyle = 'rgb(255, 0, 0)';
ctx.beginPath();
ctx.moveTo(50, 50);
// draw your path
ctx.fill();
```

#### 画线

让我们在画布上绘制一个等边三角形。

1. 首先，在代码底部添加以下帮助器函数。这会将度值转换为弧度，这很有用，因为每当您需要在JavaScript中提供角度值时，它几乎总是以弧度为单位，但是人类通常以度为单位。

   ```js
   function degToRad(degrees) {
     return degrees * Math.PI / 180;
   };
   ```

2. 接下来，通过在之前添加的内容下面添加以下内容来开始您的工作；在这里，我们为三角形设置颜色，开始绘制路径，然后将笔移至（50，50），而未绘制任何内容。那就是我们开始绘制三角形的地方。

   ```js
   ctx.fillStyle = 'rgb(255, 0, 0)';
   ctx.beginPath();
   ctx.moveTo(50, 50);
   ```

3. 现在，在脚本底部添加以下行：

   ```js
   ctx.lineTo(150, 50);
   let triHeight = 50 * Math.tan(degToRad(60));
   ctx.lineTo(100, 50+triHeight);
   ctx.lineTo(50, 50);
   ctx.fill();
   ```

   让我们依次执行以下操作：

   首先，我们在（150，50）上画一条线-现在，我们的路径沿x轴向右移动100个像素。

   其次，我们使用一些简单的三角函数求出等角三角形的高度。基本上，我们绘制的三角形朝下。等角三角形中的角度始终为60度。要计算高度，我们可以将其分成两个直角三角形，中间分别成90度，60度和30度角。从侧面看：

   - 最长的边称为**斜边**
   - 60度角旁边的一侧称为**相邻边** -我们知道它是50像素，因为它只是我们绘制的线的一半。
   - 与60度角相反的一侧称为**相反**，这是我们要计算的三角形的高度。

   ![img](https://mdn.mozillademos.org/files/14829/trigonometry.png)

   一个基本的三角公式指出，相邻的长度乘以该角度的切线等于相反的值，因此得出`50 * Math.tan(degToRad(60))`。`degToRad()`如[`Math.tan()`](1/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan)预期的以弧度为单位的输入值，我们使用函数将60度转换为弧度。

4. 计算出高度后，我们向绘制另一条线`(100, 50 + triHeight)`。X坐标很简单；它必须位于我们设置的前两个X值之间。另一方面，Y值必须为50加三角形的高度，因为我们知道三角形的顶部距离画布的顶部50个像素。

5. 下一条线将一条线绘制回三角形的起点。

6. 最后，我们运行`ctx.fill()`结束路径并填写形状。

#### 画圆

现在让我们看一下如何在画布上绘制一个圆。这是使用[`arc()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/arc)方法完成的，该方法会在指定点绘制全部或部分圆。

1. 让我们在画布上添加一条弧线-在代码底部添加以下内容：

   ```js
   ctx.fillStyle = 'rgb(0, 0, 255)';
   ctx.beginPath();
   ctx.arc(150, 106, 50, degToRad(0), degToRad(360), false);
   ctx.fill();
   ```

   `arc()`需要六个参数。前两个指定圆弧中心的位置（分别为X和Y）。第三个是圆的半径，第四个和第五个是绘制圆的开始和结束角度（因此，指定0和360度可得到一个完整的圆），第六个参数定义是否应逆时针绘制圆（逆时针）或顺时针（`false`顺时针）。

   **注意**：0度位于水平右侧。

2. 让我们尝试添加另一个弧：

   ```js
   ctx.fillStyle = 'yellow';
   ctx.beginPath();
   ctx.arc(200, 106, 50, degToRad(-45), degToRad(45), true);
   ctx.lineTo(200, 106);
   ctx.fill();
   ```

   这里的模式非常相似，但是有两个区别：

   - 我们已经确定的最后一个参数`arc()`来`true`，这意味着圆弧绘制逆时针，其中，即使弧被指定为开始于-45度和45度结束部件，我们得出各地的270度弧形不是这部分里面。如果要更改`true`为`false`然后重新运行代码，则只会绘制圆的90度切片。
   - 在调用之前`fill()`，我们在圆心处画一条线。这意味着我们得到了相当不错的吃豆人风格的抠图。如果删除了这条线（尝试一下！），然后重新运行代码，您将仅在圆弧的起点和终点之间切掉圆的边缘。这说明了画布的另一个重要点-如果您尝试填充不完整的路径（即未关闭的路径），浏览器将在起点和终点之间填充一条直线，然后将其填充。



### 文本



画布还具有用于绘制文本的功能。

使用两种方法绘制文本：

- [`fillText()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/fillText) —绘制填充文本。
- [`strokeText()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/strokeText) —绘制轮廓（描边）文本。

两者在基本用法上都具有三个属性：要绘制的文本字符串以及**文本框**（实际上是围绕所绘制**文本的框）**左上角的X和Y坐标。

还有许多属性可帮助控制文本渲染，例如[`font`](1/en-US/docs/Web/API/CanvasRenderingContext2D/font)，可让您指定字体系列，大小等。它的值与CSS [`font`]( /font)属性的语法相同。

尝试将以下块添加到JavaScript的底部：

```js
ctx.strokeStyle = 'white';
ctx.lineWidth = 1;
ctx.font = '36px arial';
ctx.strokeText('Canvas text', 50, 50);

ctx.fillStyle = 'red';
ctx.font = '48px georgia';
ctx.fillText('Canvas text', 50, 150);
```



### 将图像绘制到画布上



可以将外部图像渲染到画布上。这些可以是简单的图像，视频的帧或其他画布的内容。目前，我们仅研究在画布上使用一些简单图像的情况。

1. 和以前一样，为我们的画布模板制作另一个新副本（[1_canvas_template.html](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/1_canvas_template.html)），以在其中绘制新示例。在这种情况下，您还需要将我们的示例图像的副本[firefox.png](https://github.com/mdn/learning-area/blob/master/javascript/apis/drawing-graphics/getting-started/firefox.png)保存在同一目录中。

   使用该[`drawImage()`](1/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage)方法将图像绘制到画布上。最简单的版本具有三个参数-对要渲染的图像的引用，以及图像左上角的X和Y坐标。

2. 让我们开始将图像源嵌入到画布中。将以下行添加到JavaScript的底部：

   ```js
   let image = new Image();
   image.src = 'firefox.png';
   ```

   在这里，我们[`HTMLImageElement`](1/en-US/docs/Web/API/HTMLImageElement)使用[`Image()`](1/en-US/docs/Web/API/HTMLImageElement/Image)构造函数创建一个新对象 。返回的对象与您获取对现有[`![img]()`](1/en-US/docs/Web/HTML/Element/img)元素的引用时返回的对象具有相同的类型。然后，我们将其`src`属性设置为等于我们的Firefox徽标图像。此时，浏览器开始加载图像。

3. 现在，我们可以尝试使用来嵌入图像`drawImage()`，但是我们需要确保首先加载了图像文件，否则代码将失败。我们可以使用`onload`事件处理程序来实现此目的，该事件处理程序仅在图像加载完成后才被调用。在上一个模块下面添加以下模块：

   ```js
   image.onload = function() {
     ctx.drawImage(image, 50, 50);
   }
   ```

   如果现在在浏览器中加载示例，则应该看到图像嵌入在画布中。

4. 但是还有更多！如果我们只想显示图像的一部分或调整其大小怎么办？我们可以使用更复杂的`drawImage()`。`ctx.drawImage()`像这样更新您的行：

   ```js
   ctx.drawImage(image, 20, 20, 185, 175, 50, 50, 185, 175);
   ```

   - 和以前一样，第一个参数是图像参考。
   - 参数2和3定义要从加载的图像中切出的区域的左上角相对于图像本身的左上角的坐标。在第一个参数左侧或第二个参数上方不会绘制任何内容。
   - 参数4和5定义了我们要从加载的原始图像中切出的区域的宽度和高度。
   - 参数6和7定义相对于画布的左上角要在其上绘制图像的切除部分的左上角的坐标。
   - 参数8和9定义了宽度和高度，以绘制图像的剪切区域。在这种情况下，我们指定了与原始切片相同的尺寸，但是您可以通过指定不同的值来调整尺寸